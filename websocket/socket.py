import asyncio
import websockets
import json
import time
import os
from app import ProctoringSession  # Import the synchronous, blocking session class

# We need to explicitly set up an event loop policy for Windows
# if using Python < 3.8. This is good practice anyway.
if os.name == 'nt':
    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())

async def send_json(websocket, data: dict):
    """Helper function to send JSON data to the client."""
    try:
        await websocket.send(json.dumps(data))
    except websockets.exceptions.ConnectionClosed:
        # This is expected if the client disconnects, no need to log error
        pass

async def handle_connection(websocket):
    """
    Handles a single client connection from start to finish.
    One instance of this function runs for each connected user.
    """
    print(f"New connection from {websocket.remote_address}")
    
    # 1. Create a new, dedicated proctoring session for this user.
    try:
        start_init = time.time()
        print("Initializing new proctoring session in thread...")
        proctor = await asyncio.to_thread(ProctoringSession)
        print(f"Session initialized in {time.time() - start_init:.2f}s")
            
    except Exception as e:
        print(f"Failed to initialize session: {e}")
        await send_json(websocket, {"event": "ERROR", "message": f"Failed to initialize session: {e}"})
        await websocket.close()
        return

    try:
        # --- 2. Registration Phase ---
        print(f"[{websocket.remote_address}] Waiting for registration frame...")
        reg_frame_bytes = await websocket.recv()
        
        is_registered, message = await asyncio.to_thread(proctor.register_user_from_frame, reg_frame_bytes)
        
        if not is_registered:
            print(f"[{websocket.remote_address}] Registration failed: {message}")
            await send_json(websocket, {"event": "UNAUTHORIZED", "message": message})
            await websocket.close()
            return
        
        print(f"[{websocket.remote_address}] User REGISTERED.")
        await send_json(websocket, {"event": "AUTHORIZED", "message": "Registration successful. Proctoring session started."})

        # --- 3. Proctoring Loop Phase ---
        async for message in websocket:
            
            # --- Check for text messages (like END_SESSION) ---
            if isinstance(message, str):
                try:
                    data = json.loads(message)
                    if data.get("event") == "END_SESSION":
                        print(f"[{websocket.remote_address}] User requested to end session.")
                        await send_json(websocket, {"event": "SESSION_ENDED", "message": "Session ended by user."})
                        break # Exit the loop to close the connection
                except json.JSONDecodeError:
                    print(f"[{websocket.remote_address}] Received invalid JSON: {message}")
                continue # Skip to the next message

            # --- Process frame (binary message) ---
            frame_bytes = message
            
            # Run the heavy, blocking ML logic in a separate thread
            events_list = await asyncio.to_thread(proctor.process_frame, frame_bytes)
            
            # Send any and all events that were generated by this frame
            if events_list:
                for event in events_list:
                    print(f"[{websocket.remote_address}] Sending event: {event['event']}")
                    await send_json(websocket, event)

    except websockets.exceptions.ConnectionClosedOK:
        print(f"[{websocket.remote_address}] Connection closed gracefully (OK).")
    except websockets.exceptions.ConnectionClosedError as e:
        print(f"[{websocket.remote_address}] Connection closed with error: {e}")
    except Exception as e:
        print(f"[{websocket.remote_address}] An unexpected error occurred: {e}")
        try:
            await send_json(websocket, {"event": "ERROR", "message": str(e)})
        except:
            pass
    
    finally:
        # --- 4. Graceful Shutdown ---
        print(f"[{websocket.remote_address}] Cleaning up resources...")
        del proctor
        print(f"[{websocket.remote_address}] Session ended.")

async def main():
    """Main function to start the WebSocket server."""
    host = "0.0.0.0"
    port = 8765
    print(f"Starting WebSocket server on ws://{host}:{port}...")
    
    # Set max_size to handle large video frames (e.g., 2MB)
    # --- THIS IS THE FIX ---
    # We disable the keepalive ping, as it's redundant (we get video frames)
    # and causes timeouts when the event loop is busy with ML.
    async with websockets.serve(
        handle_connection,
        host,
        port,
        max_size=2_097_152,
        ping_interval=None  # Disable keepalive pings
    ):
        await asyncio.Future()  # Run forever

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nServer shutting down.")

